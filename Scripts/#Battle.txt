//==================================================================//
//============<    OCTOBATTLE GAMEMODE BY #OCTOTHORP    >===========//
//============<                  V 1.0                  >===========//
//==================================================================//
//=====================< OCTOBATTLE - settings >====================//
//=============================<general>============================//
private const bool SHOW_SETTINGS = true;							// set to "true" to announce settings in the beginning
private const bool GIB_ON_LEAVE = true;								// set to "true" to gib players when they leave
//==========================<hardcore mode>=========================//
private const bool HARDCORE_ACTIVATED = true;					// set to "true" to enable custom damage mode
private const float HC_GUNS_MULTIPLIER = (float) 2.0;				// damage multiplier for guns
private const float HC_MELEE_MULTIPLIER = (float) 2.0;				// damage multiplier for melee
private const float HC_FALL_MULTIPLIER = (float) 3.5;				// damage multiplier for fall
private const float HC_FIRE_MULTIPLIER = (float) 3.0;				// damage multiplier for fire
private const float HC_EXPL_MULTIPLIER = (float) 2.0;				// damage multiplier for explosions
private const bool HC_BLEEDING = true;								// set te "true" to enable bleeding on getting some damage
private const int HC_BLEEDING_CHANCE = 3;							// bleeding will start with chance "1/x" where x is this variable
private const float HC_BLEEDING_TRIGGER_HP = (float) 20;			// damage in hp after that bleeding will start find a chance
private const bool HC_CANT_PUT_FIRE_OFF = false;					// set to "true" to disallow players to roll to stop burning
//private const bool HC_WEAPONS_BREAK = false;						// set to "true" to allow weapons to break [WIP]
//========================<revive system>===========================//
private const bool REVIVE_ACTIVATED = true;							// set to "true" to activate reviving system
private const bool REVIVE_TEAMMATES_FASTER = true;					// set to "true" to revive teammates faster
private const int REVIVE_DURATION = 8;								// time in seconds needed to stay at dead player to revive him
private const int REVIVE_TIME_ALIVE = 25;							// time in seconds for recently died player to be revived
private const bool REVIVE_CAPTURE_ENEMIES = true;					// set to "true" to allow reviving enemies and making them allies
private const bool REVIVE_BLEEDING = true;							// set to "true" to make players bleed before death
private const bool REVIVE_FINISH_PLAYERS = true;					// set to "true" to allow players finish people
private const int REVIVE_FINISH_HEALTH = 20;						// health of unfinished player
//========================<instagib mode>===========================//
private const bool INSTAGIB_ACTIVATED = false;						// set to "true" to activate instagib mode
private const bool INSTAGIB_RANDOM = true;							// set to "true" to make instagib randomly appear with selected chance
private const int INSTAGIB_DELAY = 4000;							// time in ms after that players would be given a weapon
private const int INSTAGIB_CHANCE = 5;								// instagib will start with chance "1/x" where x is this variable
private const bool INSTAGIB_MELEE = false;							// set to "true" to set melee weapons only
private const bool INSTAGIB_EXPLODE = true;							// set to "true" explode players on death
//=========================<commentator>============================//
private const bool COMMENT_ACTIVATED = false;						// set to "true" to make commenter speak through pop-ups
private const int COMMENT_TYPE_SPEED = 50;							// number of leters per seconds when the commenter speaks
//==================================================================//
//=================< DO NOT TOUCH ANYTHING IN BELOW >===============//
//==============< IF YOU'RE NOT SURE WHAT YOU'RE DOING >============//
//==================================================================//


private Random rand = new Random();
private bool INSTAGIB_ON = false;
private int currentChar = 1;
private string text = "";
private string [] typingMachine_templatesWelcome = new string []{
	"Welcome everyone!",
	"May the best wins!",
	"Where is my pop-corn?",
	"Internet explorer is proud to wish you a good year 2002!" };
private string [] typingMachine_templatesRevive = new string [] {
	"{0} is back!",
	"{0} has been revived by {1}",
	"{0} was saved by {1}",
	"{0} got on his feet with help of {1}",
	"{0} wasn't supposed to be dead?" };
private string [] typingMachine_templatesDeath= new string [] {
	"{0} is knocked down",
	"{0} failed a saving throw!",
	"{0} is dead because of lags",
	"{0} wasn't my bet anyway!" };
private string [] typingMachine_templatesGib = new string [] {
	"{0} has spilled his/her guts on the ground",
	"{0}'s blood painted the wall in red!",
	"{0} felt no pain (in fact yes)",
	"{0} is looking like an IKEA kit!",
	"{0} will never looks the same"}; 
private string [] typingMachine_templatesDisconnect = new string [] {
	"{0} left us",
	"{0} gave up",
	"{0} abandoned the battle",
	"{0} knew it wasn't his war!",
	"{0} cowardly ran away"}; 

// ============================ |
// ========< THE CODE >======== |
// ============================ V



// where players' data will be stored
private class DeadPlayerData {
	public float DeathTime = 0f;
	public IUser User = null;
	public IPlayer Body = null;
	public int RevivePoints = 0;
	public float DamageTaken = 0f;
	public IObjectText Label = null;
	public PlayerTeam Team = PlayerTeam.Independent;
	public DeadPlayerData(float deathTime, IUser user, IPlayer body, IObjectText label, PlayerTeam team, float damageTaken){
		this.DeathTime = deathTime;
		this.User = user;
		this.Body = body;
		this.Label = label;
		this.Team = team;
		this.DamageTaken = damageTaken;
	}
}

private class PlayerData {
	public float StartHealth = 0f;
	public float LastHealth = 100f;
	public float LastDamage = 0f; 
	public float BleedDamage = 0f;
	public float HealthNeeded = 0f;
	public float HealthAdded = 0f;
	public IUser User = null;
	public IPlayer Body = null;
	public bool WasSetOnFire = false;
	public bool IsBleeding = false;
	public PlayerData(float startHealth, IUser user, IPlayer body, bool wasSetOnFire){
		this.StartHealth = startHealth;
		this.User = user;
		this.Body = body;
		this.WasSetOnFire = wasSetOnFire;
	}
}

public void OnStartup(){
	INSTAGIB_ON = (INSTAGIB_ACTIVATED && (rand.Next(INSTAGIB_CHANCE) == 0 || !INSTAGIB_RANDOM));

	// set up the triggers
		// fast tick trigger
		IObjectTimerTrigger timerTriger = (IObjectTimerTrigger)Game.CreateObject("TimerTrigger"); 
		timerTriger.SetIntervalTime(100);
		timerTriger.SetRepeatCount(0);
		timerTriger.SetScriptMethod("TickFast");
		timerTriger.Trigger();
		// medium tick trigger
		IObjectTimerTrigger timerTriger2 = (IObjectTimerTrigger)Game.CreateObject("TimerTrigger"); 
		timerTriger2.SetIntervalTime(500);
		timerTriger2.SetRepeatCount(0);
		timerTriger2.SetScriptMethod("TickMid");
		timerTriger2.Trigger();
		// death tigger
		IObjectTrigger deathTrigger = (IObjectTrigger)Game.CreateObject("OnPlayerDeathTrigger"); 
		deathTrigger.SetScriptMethod("Death");

		// show settings trigger
		if (SHOW_SETTINGS){
			ShowSettings();
			IObjectTimerTrigger timerTriger3 = (IObjectTimerTrigger)Game.CreateObject("TimerTrigger"); 
			timerTriger3.SetIntervalTime(5000);
			timerTriger3.SetRepeatCount(1);
			timerTriger3.SetScriptMethod("HideSettings");
			timerTriger3.Trigger();
		}

	// settings based method executions
	if (INSTAGIB_ON)  Prepare_Instagib();
	else if (HARDCORE_ACTIVATED) Prepare_CustomDamage();

	Game.RunCommand("/MSG #Battle v1.0");
}

public void TickFast(TriggerArgs args){
	if (INSTAGIB_ON) Tick_Instagib();
	if (HARDCORE_ACTIVATED && !INSTAGIB_ON) Tick_CustomDamage();

}

public void TickMid(TriggerArgs args){
	if (REVIVE_ACTIVATED && !INSTAGIB_ON) Tick_Revive();
}


public void ShowSettings(){
	string settings = "";
	if (INSTAGIB_ON){
		settings += "| - Instagib mode\n";
		if (INSTAGIB_EXPLODE) settings += "   | - explode players is ON\n";
			else settings += "   | - explode players is OFF\n";
	} else {
		if (HARDCORE_ACTIVATED){
			settings += "| - custom damage mode is ON\n";
			if (HC_BLEEDING) settings += "   | - bleeding is ON\n";
				else settings += "   | - bleeding is OFF\n";
			/*if (HC_WEAPONS_BREAK) settings += "   | - weapon break is ON\n";
				else settings += "   | - weapon break is OFF\n";*/
			if (HC_CANT_PUT_FIRE_OFF) settings += "   | - can't put fire off is ON\n";
				else settings += "   | - can't put fire off is OFF\n";
		} else settings += "| - custom damage mode is OFF\n";
		if (REVIVE_ACTIVATED){
			settings += "| - Revive is ON\n";
			if (REVIVE_CAPTURE_ENEMIES) settings += "   | - capture enemies is ON\n";
				else settings += "   | - capture enemies is OFF\n";
			if (REVIVE_FINISH_PLAYERS) settings += "   | - finish players is ON\n";
				else settings += "   | - finish players is OFF\n";
		} else settings += "| - Revive is OFF\n";
	}
	if (COMMENT_ACTIVATED) settings += "| - Commentator is ON\n";
		else settings += "| - Commentator is OFF\n";
	Game.ShowPopupMessage("Current OctoBattle settings:\n" + settings, new Color(100,220,255));
}

public void HideSettings(TriggerArgs args){
	//Welcoming message
	if (COMMENT_ACTIVATED) TypingMachine_Print("beginning" , new string[]{""});
	else Game.HidePopupMessage();
}

private List<DeadPlayerData> deadPlayers = new List<DeadPlayerData>();
public void Death(TriggerArgs args){
	IPlayer ply = (IPlayer)args.Sender;
	IUser user = ply.GetUser();

	if (user == null && GIB_ON_LEAVE){
		ply.Gib();
	} else {
		// add dead player to list
		if ((!INSTAGIB_ON) && ply != null && !ply.IsRemoved && user!= null){
			IObjectText label = (IObjectText)Game.CreateObject("Text", ply.GetWorldPosition() + new Vector2(-6, 16), 0);
			float damage = ply.Statistics.TotalExplosionDamageTaken + ply.Statistics.TotalFallDamageTaken +
				ply.Statistics.TotalFireDamageTaken + ply.Statistics.TotalMeleeDamageTaken + ply.Statistics.TotalProjectileDamageTaken;
			deadPlayers.Add(new DeadPlayerData(Game.TotalElapsedGameTime, user, ply, label, ply.GetTeam(), damage));
		}
	}
	if (COMMENT_ACTIVATED){
		if (ply.GetUser() != null) TypingMachine_Print("death" , new string[] {ply.GetUser().Name});
		else TypingMachine_Print("disconnect", new string[] {ply.GetProfile().Name});
	}
}

// ============================= |
// =========< OPTIONS >========= |
// ============================= V

public void Tick_Revive(){
	// travel through dead players list
	for(int i = deadPlayers.Count - 1; i >=0; i--){
		IPlayer body = deadPlayers[i].Body;
		// check if body is present and time's not passed
		if (body != null && !body.IsRemoved &&
		((Game.TotalElapsedGameTime - deadPlayers[i].DeathTime < (REVIVE_TIME_ALIVE * 1000f)) || deadPlayers[i].RevivePoints != 0)){
			bool revivingNow = false;
			bool spawnedNow = false;
			bool diedNow = false;
			deadPlayers[i].Label.Remove();
			IObjectText label = (IObjectText)Game.CreateObject("Text", body.GetWorldPosition() + new Vector2(-6, 16), 0);

			float damage = body.Statistics.TotalExplosionDamageTaken + body.Statistics.TotalFireDamageTaken + body.Statistics.TotalMeleeDamageTaken
				+ body.Statistics.TotalProjectileDamageTaken + (body.Statistics.TotalFallDamageTaken / 5f);
			if (REVIVE_FINISH_PLAYERS && damage > deadPlayers[i].DamageTaken + (float)REVIVE_FINISH_HEALTH){
				diedNow = true;
				deadPlayers.RemoveAt(i);
			}

			// check for crouching players nearby
			if (!diedNow){
				foreach (IPlayer ply in Game.GetPlayers()){
					if ((ply.GetWorldPosition() - body.GetWorldPosition()).LengthSquared() < 144 && ply.IsCrouching &&
						(REVIVE_CAPTURE_ENEMIES || ply.GetTeam() == deadPlayers[i].Team)){
						revivingNow = true;
						// spawn player if enough time passed
						if (deadPlayers[i].RevivePoints >= REVIVE_DURATION * 2){
							// spawn player
							if (UserStillHere(deadPlayers[i].User))	RevivePlayer(body, ply, deadPlayers[i].User, ply.GetTeam());
							// if disconnected, gib body
							else body.Gib();
							// remove the rest
							label.Remove();
							deadPlayers.RemoveAt(i);

							spawnedNow = true;
							break;
						} else {
							// make team revives faster
							if (ply.GetTeam() == deadPlayers[i].Team || !REVIVE_TEAMMATES_FASTER) 
								deadPlayers[i].RevivePoints += 2;
							else
								deadPlayers[i].RevivePoints ++;
						}
					}
				} 
			}
			// if player just spawned, do not do anything else
			if (!spawnedNow && !diedNow){
				if (deadPlayers[i].RevivePoints != 0 && !revivingNow) deadPlayers[i].RevivePoints = 0;
				if (REVIVE_BLEEDING) Game.PlayEffect("TR_B",body.GetWorldPosition() + new Vector2(rand.Next(-4,4),rand.Next(-4,4)));
				// draw time left if not being revived
				if (!revivingNow){
					int totalSeconds = (int)((REVIVE_TIME_ALIVE*1000f + deadPlayers[i].DeathTime - Game.TotalElapsedGameTime) / 1000f);
					int minutes = totalSeconds / 60;
					int seconds = totalSeconds - (minutes * 60);

					label.SetText(deadPlayers[i].User.GetProfile().Name + "\n" + string.Format(minutes.ToString() + ":{0:00}", seconds));
					label.SetTextColor(GetTeamColor(deadPlayers[i].Team));
				}
				// draw progress of reviving if is being revived
				else {
					label.SetWorldPosition(body.GetWorldPosition() + new Vector2(-28, 16));
					int progress = (int)(10f * ((float)deadPlayers[i].RevivePoints / (REVIVE_DURATION * 2f)));
					string filling = "";
					for (int j = 1; j <= progress; j++) filling += "=";
					if (progress != 10) filling += ">";
					for (int j = progress + 2; j <= 10; j++)	filling += "  ";

					label.SetText(deadPlayers[i].User.GetProfile().Name + "\n" + string.Format("[" + filling + "]"));
					label.SetTextColor(GetTeamColor(deadPlayers[i].Team));
				}

				deadPlayers[i].Label = label;
			}
		// if player's body is removed, gibbed or time has run out, remove entry from list
		} else {
			deadPlayers[i].Label.Remove();
			deadPlayers.RemoveAt(i);
		}
	}
}

public void RevivePlayer(IPlayer body, IPlayer reviver, IUser user, PlayerTeam team){
	float health = (float)rand.Next(15,50);

	IPlayer revivedPlayer = Game.CreatePlayer(body.GetWorldPosition());
	revivedPlayer.SetUser(user);
	revivedPlayer.SetProfile(user.GetProfile());
	revivedPlayer.SetHealth(health);
	revivedPlayer.SetTeam(team);
	body.Remove();
	Game.PlayEffect("PWT", revivedPlayer.GetWorldPosition(), "REVIVE!");

	if (HARDCORE_ACTIVATED) players.Add(new PlayerData(health, revivedPlayer.GetUser(), revivedPlayer, false));
	if (COMMENT_ACTIVATED) TypingMachine_Print("revive" , new string[] {revivedPlayer.GetProfile().Name, reviver.GetProfile().Name});
}

public void Tick_Instagib(){
	foreach (IPlayer ply in Game.GetPlayers()){
		float damage = 0f;
		if (INSTAGIB_MELEE){
			ply.SetHealth(100f - ply.Statistics.TotalDamageTaken + ply.Statistics.TotalExplosionDamageTaken);
			damage = ply.Statistics.TotalMeleeDamageTaken + ply.Statistics.TotalProjectileDamageTaken;
		} else damage = ply.Statistics.TotalProjectileDamageTaken;

		if (damage != 0){
			if (INSTAGIB_EXPLODE) Game.TriggerExplosion(ply.GetWorldPosition());
			if (COMMENT_ACTIVATED) TypingMachine_Print("gib" , new string[] {ply.GetProfile().Name});
			ply.Gib();
		}
	}
}

public void Prepare_Instagib(){
	Game.RunCommand("/IA 1");
	foreach (IObject obj in Game.GetObjectsByName(new string[]{"SpawnWeapon", "SpawnWeaponArea", "SpawnWeaponAreaCeiling"})){
		obj.Remove();
	}

	IObjectTimerTrigger timerTriger = (IObjectTimerTrigger)Game.CreateObject("TimerTrigger"); 
	timerTriger.SetIntervalTime(INSTAGIB_DELAY);
	timerTriger.SetRepeatCount(1);
	timerTriger.SetScriptMethod("Prepare_Instagib_GiveSnipers");
	timerTriger.Trigger();
}

public void Prepare_Instagib_GiveSnipers(TriggerArgs args){
	foreach (IPlayer ply in Game.GetPlayers()){
		ply.GiveWeaponItem(WeaponItem.SNIPER);
	}
}

private List<PlayerData> players = new List<PlayerData>();
public void Prepare_CustomDamage(){
	foreach (IPlayer ply in Game.GetPlayers())
		if (ply.GetUser() != null)
			players.Add(new PlayerData(100f, ply.GetUser(), ply, false));
}

public void Tick_CustomDamage(){
	for(int i = players.Count - 1; i >=0; i--){
		PlayerData data = players[i];
		if (data.Body.IsDead || data.Body.IsRemoved) players.RemoveAt(i);
		else {
			IPlayerStatistics stats = data.Body.Statistics;
			float damage =
				stats.TotalFallDamageTaken * HC_FALL_MULTIPLIER +
				stats.TotalMeleeDamageTaken * HC_MELEE_MULTIPLIER +
				stats.TotalProjectileDamageTaken * HC_GUNS_MULTIPLIER +
				stats.TotalExplosionDamageTaken * HC_EXPL_MULTIPLIER +
				stats.TotalFireDamageTaken * HC_FIRE_MULTIPLIER +
				data.BleedDamage;
			float damage_causingBleed = stats.TotalMeleeDamageTaken * HC_MELEE_MULTIPLIER +
				stats.TotalProjectileDamageTaken * HC_GUNS_MULTIPLIER +
				stats.TotalExplosionDamageTaken * HC_EXPL_MULTIPLIER;

			if (data.StartHealth - damage > 0f){
				float healthNow = data.Body.GetHealth();
				if (healthNow > data.LastHealth && data.HealthNeeded < healthNow - data.LastHealth){
					if (data.IsBleeding){
						data.IsBleeding = false;
						data.HealthNeeded += healthNow - data.LastHealth - 25f;
					} else data.HealthNeeded += healthNow - data.LastHealth - 15f;
				} else if (data.HealthNeeded > 0f){
					data.HealthAdded += 0.5f;
					data.HealthNeeded -= 0.5f;
				} else data.HealthNeeded = 0f;

				if (data.WasSetOnFire){
					data.Body.SetMaxFire();
				}

				if (data.IsBleeding){
					data.BleedDamage += 0.1f;
					if (rand.Next(6) == 0)
					Game.PlayEffect("TR_B", data.Body.GetWorldPosition() + new Vector2(8,0) + new Vector2(rand.Next(-2,2),rand.Next(-2,2)));
				}

				data.Body.SetHealth(data.StartHealth - damage + data.HealthAdded);
				if (HC_BLEEDING && damage_causingBleed - data.LastDamage > HC_BLEEDING_TRIGGER_HP && rand.Next(HC_BLEEDING_CHANCE) == 0){ 
					data.IsBleeding = true;
					Game.PlayEffect("PWT", data.Body.GetWorldPosition(), "BLEEDING!");
				} if (HC_CANT_PUT_FIRE_OFF && stats.TotalFireDamageTaken != 0) data.WasSetOnFire = true;
				data.LastHealth = data.Body.GetHealth();
				data.LastDamage = damage_causingBleed;
			} else data.Body.Kill();
		}
	}
}

// ============================= |
// =========< HELPERS >========= |
// ============================= V

public Color GetTeamColor(PlayerTeam team){
	if (team == PlayerTeam.Team1) return new Color(124, 124, 246);
	if (team == PlayerTeam.Team2) return new Color(245, 78, 78);
	if (team == PlayerTeam.Team3) return new Color(5, 219, 5);
	if (team == PlayerTeam.Team4) return new Color(214, 214, 0);
	return new Color(255, 255, 255);
}

public bool UserStillHere(IUser user){
	foreach (IUser usr in Game.GetActiveUsers())
		if (usr.UserId == user.UserId) return true;
	return false;
}


public void TypingMachine_Print(string reason, string[] args) {

	// determine what type of text should be displayed
	switch (reason){
		case "death" : text = string.Format(typingMachine_templatesDeath[rand.Next(typingMachine_templatesDeath.Length)], args[0]); break;
		case "revive" : text = string.Format(typingMachine_templatesRevive[rand.Next(typingMachine_templatesRevive.Length)], args[0], args[1]); break;
		case "beginning" : text = typingMachine_templatesWelcome[rand.Next(typingMachine_templatesWelcome.Length)]; break; 
		case "gib" : text = string.Format(typingMachine_templatesGib[rand.Next(typingMachine_templatesGib.Length)], args[0]); break;
		case "disconnect" :  text = string.Format(typingMachine_templatesDisconnect[rand.Next(typingMachine_templatesDisconnect.Length)], args[0]); break;
		default : break;
	}

	// reset speaker engine
	currentChar = 0;
	foreach (IObject obj in (IObject[])Game.GetObjectsByCustomId("TypingMachineTrigger"))obj.Remove();

	// create a speaker engine
	IObjectTimerTrigger timerTrigger = (IObjectTimerTrigger)Game.CreateObject("TimerTrigger"); 
	timerTrigger.SetIntervalTime(1000/COMMENT_TYPE_SPEED);
	timerTrigger.SetRepeatCount(0);
	timerTrigger.SetScriptMethod("TypingMachine_AddLetter");
	timerTrigger.CustomId = "TypingMachineTrigger";
	timerTrigger.Trigger();
}

public void TypingMachine_AddLetter(TriggerArgs args) {
	if (currentChar < text.Length) {
		currentChar ++;
		Game.ShowPopupMessage(text.Substring(0, currentChar));
		Game.PlaySound("OutOfAmmoLight", Vector2.Zero, 1f);
	}
	else {
		foreach (IObject obj in (IObject [])Game.GetObjectsByCustomId("TypingMachineTrigger"))obj.Remove();
		TypingMachine_Stop();
	}
}

public void TypingMachine_Stop(){
	IObjectTimerTrigger timerTrigger = (IObjectTimerTrigger)Game.CreateObject("TimerTrigger"); 
	timerTrigger.SetIntervalTime(3000);
	timerTrigger.SetRepeatCount(1);
	timerTrigger.SetScriptMethod("TypingMachine_Clear");
	timerTrigger.CustomId = "TypingMachineTrigger";
	timerTrigger.Trigger();
}

public void TypingMachine_Clear(TriggerArgs args){
	Game.HidePopupMessage();
}